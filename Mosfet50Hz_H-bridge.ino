#include <stdint.h>

int8_t pwm = 1;

#define PUSHPULL_DRIVE_1 33
#define PUSHPULL_DRIVE_2 25
#define SELF_TRIGGERING_IRQ 0
#define DRIVE1_PWM 1
#define DRIVE2_PWM 2
#define CYCLE_START_PIN 35 //pin connected to the optocoupler that detects the zero crossing of the mains sine wave
#define INPUT_ZCD 34 //pin connected to the optocoupler that detects the zero crossing of the mains sine wave
#define OUTPUT_PIN 27 //pin connected to 35

const byte  led_gpio    =   32;
int32_t PWM_FEEDBACK_PIN = 18;
int phaseOffset = 25; // 25 degrees phase offset

#define MODULATING_FREQ         18002   // <-- 18KHz is 360 x 50 Hz for American 60Hz use number 21600 instead
#define MAX_STEPS               360     //  one pwm update per degree of mains sine
#define TRANSISTOR_SWITCH_STEP  179     // when to use other transistor bank

int32_t sinetable[]= 
{
0 ,
4 ,
8 ,
13  ,
17  ,
22  ,
26  ,
31  ,
35  ,
39  ,
44  ,
48  ,
53  ,
57  ,
61  ,
65  ,
70  ,
74  ,
78  ,
83  ,
87  ,
91  ,
95  ,
99  ,
103 ,
107 ,
111 ,
115 ,
119 ,
123 ,
127 ,
131 ,
135 ,
138 ,
142 ,
146 ,
149 ,
153 ,
156 ,
160 ,
163 ,
167 ,
170 ,
173 ,
177 ,
180 ,
183 ,
186 ,
189 ,
192 ,
195 ,
198 ,
200 ,
203 ,
206 ,
208 ,
211 ,
213 ,
216 ,
218 ,
220 ,
223 ,
225 ,
227 ,
229 ,
231 ,
232 ,
234 ,
236 ,
238 ,
239 ,
241 ,
242 ,
243 ,
245 ,
246 ,
247 ,
248 ,
249 ,
250 ,
251 ,
251 ,
252 ,
253 ,
253 ,
254 ,
254 ,
254 ,
254 ,
254 ,
255 ,
254 ,
254 ,
254 ,
254 ,
254 ,
253 ,
253 ,
252 ,
251 ,
251 ,
250 ,
249 ,
248 ,
247 ,
246 ,
245 ,
243 ,
242 ,
241 ,
239 ,
238 ,
236 ,
234 ,
232 ,
231 ,
229 ,
227 ,
225 ,
223 ,
220 ,
218 ,
216 ,
213 ,
211 ,
208 ,
206 ,
203 ,
200 ,
198 ,
195 ,
192 ,
189 ,
186 ,
183 ,
180 ,
177 ,
173 ,
170 ,
167 ,
163 ,
160 ,
156 ,
153 ,
149 ,
146 ,
142 ,
138 ,
135 ,
131 ,
127 ,
123 ,
119 ,
115 ,
111 ,
107 ,
103 ,
99  ,
95  ,
91  ,
87  ,
83  ,
78  ,
74  ,
70  ,
65  ,
61  ,
57  ,
53  ,
48  ,
44  ,
39  ,
35  ,
31  ,
26  ,
22  ,
17  ,
13  ,
8 ,
4 ,
0 ,
5 ,
9 ,
14  ,
18  ,
23  ,
27  ,
32  ,
36  ,
40  ,
45  ,
49  ,
54  ,
58  ,
62  ,
66  ,
71  ,
75  ,
79  ,
84  ,
88  ,
92  ,
96  ,
100 ,
104 ,
108 ,
112 ,
116 ,
120 ,
124 ,
128 ,
132 ,
136 ,
139 ,
143 ,
147 ,
150 ,
154 ,
157 ,
161 ,
164 ,
168 ,
171 ,
174 ,
178 ,
181 ,
184 ,
187 ,
190 ,
193 ,
196 ,
199 ,
201 ,
204 ,
207 ,
209 ,
212 ,
214 ,
217 ,
219 ,
221 ,
224 ,
226 ,
228 ,
230 ,
232 ,
233 ,
235 ,
237 ,
239 ,
240 ,
242 ,
243 ,
244 ,
246 ,
247 ,
248 ,
249 ,
250 ,
251 ,
252 ,
252 ,
253 ,
254 ,
254 ,
255 ,
255 ,
255 ,
255 ,
255 ,
255 ,
255 ,
255 ,
255 ,
255 ,
255 ,
254 ,
254 ,
253 ,
252 ,
252 ,
251 ,
250 ,
249 ,
248 ,
247 ,
246 ,
244 ,
243 ,
242 ,
240 ,
239 ,
237 ,
235 ,
233 ,
232 ,
230 ,
228 ,
226 ,
224 ,
221 ,
219 ,
217 ,
214 ,
212 ,
209 ,
207 ,
204 ,
201 ,
199 ,
196 ,
193 ,
190 ,
187 ,
184 ,
181 ,
178 ,
174 ,
171 ,
168 ,
164 ,
161 ,
157 ,
154 ,
150 ,
147 ,
143 ,
139 ,
136 ,
132 ,
128 ,
124 ,
120 ,
116 ,
112 ,
108 ,
104 ,
100 ,
96  ,
92  ,
88  ,
84  ,
79  ,
75  ,
71  ,
66  ,
62  ,
58  ,
54  ,
49  ,
45  ,
40  ,
36  ,
32  ,
27  ,
23  ,
18  ,
14  ,
9 ,
5 ,
1
};

int32_t ctr = 0;

void isr(){

    int32_t val; // get value from sinetable

int index = (ctr + phaseOffset) % MAX_STEPS; // scale the sine tablkee and apply offset
 val = sinetable[index]; // get value from sinetable
   
    if(index>TRANSISTOR_SWITCH_STEP) // if we are past the TRANSISTOR_SWITCH_STEP
    {
        ledcWrite(DRIVE1_PWM, 0); // turn off transistor bank 1
        ledcWrite(DRIVE2_PWM, val); // turn on transistor bank 2
    }
    else
    {
        ledcWrite(DRIVE1_PWM, val); // turn on transistor bank 1
        ledcWrite(DRIVE2_PWM, 0); // turn off transistor bank 2
    }

    ctr++; // increment counter
    if (ctr >= MAX_STEPS) ctr = 0; // reset counter if we are at the end of the sinetable
}

void cycle_start_isr(){
    ctr = 0; // reset counter when a zero crossing is detected
}


void setup() {
    ledcSetup(SELF_TRIGGERING_IRQ, MODULATING_FREQ, 8); // 8 bit resolution
    ledcSetup(DRIVE1_PWM, MODULATING_FREQ, 8); // 8 bit resolution
    ledcSetup(DRIVE2_PWM, MODULATING_FREQ, 8); // 8 bit resolution

    ledcAttachPin(led_gpio, SELF_TRIGGERING_IRQ);
    ledcAttachPin(PUSHPULL_DRIVE_1, DRIVE1_PWM);
    ledcAttachPin(PUSHPULL_DRIVE_2, DRIVE2_PWM);

    pinMode(PWM_FEEDBACK_PIN, INPUT_PULLDOWN);
    attachInterrupt(CYCLE_START_PIN, cycle_start_isr, RISING); //triggers cycle_start_isr function when a rising edge is detected in the cycle start pin
    attachInterrupt(PWM_FEEDBACK_PIN, isr, RISING); //triggers isr function when a rising edge is detected in the PWM feedback pin
    

    ledcWrite(SELF_TRIGGERING_IRQ, pwm); //Means that pin 18 is basicly a clock pin at frequency MODULATING_FREQ (18KHz)
    ledcWrite(DRIVE1_PWM, 127);
    ledcWrite(DRIVE2_PWM, 127);
    pinMode(INPUT_ZCD,INPUT);
    pinMode(OUTPUT_PIN,OUTPUT);
    Serial.begin(115200);
}

void loop() {
    if(analogRead(INPUT_ZCD)>4000){
        digitalWrite(OUTPUT_PIN, HIGH);
    }
    else{
        digitalWrite(OUTPUT_PIN, LOW);
    }
}